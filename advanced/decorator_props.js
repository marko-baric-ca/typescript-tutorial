import projectConfig from '/pagic.config.js';
import Ga from '/_ga.js';
import Gitalk from '/_gitalk.js';
export default {
    'prev': {
        "text": "声明合并",
        "link": "advanced/declaration-merging.html"
    },
    'next': {
        "text": "扩展阅读",
        "link": "advanced/further-reading.html"
    },
    config: { "root": "/", ...projectConfig, branch: 'master' },
    'pagePath': "advanced/decorator.md",
    'layoutPath': "_layout.tsx",
    'outputPath': "advanced/decorator.html",
    'title': "装饰器",
    'content': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<h1>装饰器</h1>\n<p>写在前面：本章只介绍 TypeScript 5.0+ 的装饰器用法，对于 5.0 以下的版本，请参考 <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">TypeScript 官方文档</a></p>\n<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8">什么是装饰器<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8">§</a></h2>\n<p>首先，什么是装饰器呢？<a href="https://en.wikipedia.org/wiki/Decorator_pattern">维基百科</a>是这么说的：</p>\n<blockquote>\n<p>In <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented programming</a>, the <strong>decorator pattern</strong> is a <a href="https://en.wikipedia.org/wiki/Design_pattern_(computer_science)">design pattern</a> that allows behavior to be added to an individual <a href="https://en.wikipedia.org/wiki/Object_(computer_science)">object</a>, dynamically, without affecting the behavior of other instances of the same <a href="https://en.wikipedia.org/wiki/Class_(computer_science)">class</a>.</p>\n</blockquote>\n<p>本人的蹩足翻译：在 OOP (面向对象编程)中，装饰器模式是一种允许动态地往一个对象上添加自定义行为，而又不影响该对象所属的类的其他实例的一种设计模式。</p>\n<blockquote>\n<p>什么是 OOP 和类？<a href="https://ts.xcatliu.com/advanced/class.html">前面的章节</a>做过介绍。</p>\n</blockquote>\n<p>这句话未免过于拗口了，我们不妨换个角度去切入。</p>\n<h2 id="%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">装饰器的使用场景<a class="anchor" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">§</a></h2>\n<p>要知道，一切设计模式的诞生，都是为了解决某个问题。在 JavaScript 的世界中，装饰器通常出现于以下场景：</p>\n<ol>\n<li>\n<p>提供一种易读且容易实现的方式，修改类或者类的方法，避免出现大量重复的代码。</p>\n<p>下面以修改类的方法为例。</p>\n<p>首先，假设我们有一个 <code>Animal</code> 类：</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token keyword">type</span>\n  <span class="token punctuation">}</span>\n  \n  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, I\'m a(n) </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> xcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">\'cat\'</span><span class="token punctuation">)</span>\nxcat<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Hello, I\'m a(n) cat!</span>\n</code></pre>\n<p>该类有一个 greet 方法，和调用方打招呼。</p>\n<p>假如说，我还希望根据不同的 <code>type</code>，往 console 打印不同动物的叫声呢？</p>\n<p>聪明的你或许想到了，这不就是<strong>类的继承</strong>吗！在子类的 <code>greet()</code> 方法中，实现不同的逻辑，再调用 <code>super.greet()</code> 即可。</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Xcat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">\'cat\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  \n  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'meow~ meow~\'</span><span class="token punctuation">)</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> xcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Xcat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nxcat<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// meow~ meow~</span>\n             <span class="token comment">// Hello, I\'m a(n) cat!</span>\n</code></pre>\n<p>用装饰器实现，也不妨为一种思路，比如在 <code>Animal</code> 类中，为 <code>greet()</code> 方法添加「打印不同动物叫声的」行为:</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token keyword">type</span>\n  <span class="token punctuation">}</span>\n\n  @yelling\n  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, I\'m a(n) </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> typeToYellingMap <span class="token operator">=</span> <span class="token punctuation">{</span>\n  cat<span class="token operator">:</span> <span class="token string">\'meow~ meow~\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">yelling</span><span class="token punctuation">(</span>originalMethod<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> context<span class="token operator">:</span> ClassMethodDecoratorContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>typeToYellingMap<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n    <span class="token function">originalMethod</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> xcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">\'cat\'</span><span class="token punctuation">)</span>\nxcat<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// meow~ meow~</span>\n             <span class="token comment">// Hello, I\'m a(n) cat!</span>\n</code></pre>\n<p>在 <code>Animal.greet()</code> 方法上出现的 <code>@yelling</code> ，就是 TypeScript 中装饰器的写法，即 @ + 函数名的组合。</p>\n<p>上述示例对装饰器的应用属于<strong>方法装饰器</strong>，此类装饰器本身接收两个参数，一是被装饰的方法，二是方法装饰器的上下文。方法装饰器应返回一个函数，此函数在运行时真正被执行。在上述例子中，我们在装饰器返回的函数中做了两件事情：</p>\n<ol>\n<li>打印相应类别的动物的叫声。</li>\n<li>调用 <code>originalMethod.call(this, …args)</code> ，确保原方法（即装饰器所装饰的方法）能够正确地被执行。</li>\n</ol>\n</li>\n<li>\n<p>结合「<strong>依赖注入</strong>」这一设计模式，优化模块与 class 的依赖关系。</p>\n<p>什么是依赖注入呢？引用同事 <a href="https://github.com/ziofat">zio</a> 的原话：</p>\n<blockquote>\n<p><strong>依赖注入其实是将一个模块所依赖的部分作为参数传入，而不是由模块自己去构造。</strong></p>\n</blockquote>\n<p>可见，依赖注入解决了实际工程项目中，类、模块间依赖关系层级复杂的问题，将构造单例的行为交由实现依赖注入的框架去处理。</p>\n<p>举个例子：</p>\n<pre class="language-ts"><code class="language-ts">@injectable\n<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">implements</span> <span class="token class-name">IAnimal</span> <span class="token punctuation">{</span>\n  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'woof woof woof\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n@injectable\n<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">IAnimal</span> <span class="token punctuation">{</span>\n  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'meow meow meow\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">AnimalService</span> <span class="token punctuation">{</span>\n  <span class="token keyword">constructor</span><span class="token punctuation">(</span>\n    @inject dog<span class="token operator">:</span> Dog\n    @inject cat<span class="token operator">:</span> Cat\n  <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>_dog <span class="token operator">=</span> dog\n    <span class="token keyword">this</span><span class="token punctuation">.</span>_cat <span class="token operator">=</span> cat\n  <span class="token punctuation">}</span>\n  \n  <span class="token function">sayHiByDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>_dog<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  \n  <span class="token function">sayHiByCat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>_cat<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>在上述代码中，<code>@injectable</code> 将一个类标记为「可被注入的」，在面向业务的类（即 <code>AnimalService</code>）中，使用 <code>@inject</code> 注入此类的单例，实现了「依赖倒置」。注意到这里的 <code>implements IAnimal</code> 用法，也是实战中依赖注入运用的精妙之处 —— 关心接口，而非具体实现。</p>\n</li>\n<li>\n<p>实现「AOP」，即 Aspect-oriented programming，面向切面编程。</p>\n<p>所谓的「切面」，可以理解成，在复杂的各个业务维度中，只关注一个维度的事务。</p>\n<p>例如，使用装饰器，实现对类的某个方法的执行时间记录：</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>\n  @recordExecution\n  <span class="token function">myFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// do something...</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">recordExecution</span><span class="token punctuation">(</span>originalMethod<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> context<span class="token operator">:</span> ClassMethodDecoratorContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">\'mark execution\'</span><span class="token punctuation">)</span>\n    <span class="token function">originalMethod</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">\'mark execution\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n</li>\n</ol>\n<h2 id="%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%B1%BB%E5%88%AB">装饰器的类别<a class="anchor" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%B1%BB%E5%88%AB">§</a></h2>\n<p>通过以上例子，相信读者已经对装饰器有一定了解，且认识到了装饰器在一些场景的强大之处。在此引用<a href="https://es6.ruanyifeng.com/#docs/decorator#%E7%AE%80%E4%BB%8B%EF%BC%88%E6%96%B0%E8%AF%AD%E6%B3%95%EF%BC%89">阮一峰 es6 教程</a>稍做总结：</p>\n<blockquote>\n<p>装饰器是一种函数，写成<code>@ + 函数名</code>，可以用来装饰四种类型的值。</p>\n<ul>\n<li>类</li>\n<li>类的属性</li>\n<li>类的方法</li>\n<li>属性存取器（accessor, getter, setter）</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>装饰器的执行步骤如下。</p>\n<ol>\n<li>计算各个装饰器的值，按照从左到右，从上到下的顺序。</li>\n<li>调用方法装饰器。</li>\n<li>调用类装饰器。</li>\n</ol>\n</blockquote>\n<p>不管是哪种类型的装饰器，它们的函数签名都可以认为是一致的，即均接收 <code>value</code>, <code>context</code> 两个参数，前者指被装饰的对象，后者指一个存储了上下文信息的对象。</p>\n<h2 id="context-%E4%B8%8E-metadata-%E4%BA%8C%E4%B8%89%E8%AE%B2">context 与 metadata 二三讲<a class="anchor" href="#context-%E4%B8%8E-metadata-%E4%BA%8C%E4%B8%89%E8%AE%B2">§</a></h2>\n<p>四种装饰器的 context，均包含以下信息：</p>\n<ul>\n<li>\n<p>kind</p>\n<p>描述被装饰的 value 的类型，可取 <code>class</code>, <code>method</code>, <code>field</code>, <code>getter</code>, <code>setter</code>, <code>accessor</code> 这些值。</p>\n</li>\n<li>\n<p>name</p>\n<p>描述被装饰的 value 的名字。</p>\n</li>\n<li>\n<p>addInitializer</p>\n<p>一个方法，接收一个回调函数，使得开发者可以侵入 value 的初始化过程作修改。</p>\n<p>对 <code>class</code> 来说，这个回调函数会在类定义最终确认后调用，即相当于在初始化过程的最后一步。</p>\n<p>对其他的 value 来说，如果是被 <code>static</code> 所修饰的，则会在类定义期间被调用，且早于其他静态属性的赋值过程；否则，会在类初始化期间被调用，且早于 value 自身的初始化。</p>\n<p>以下是 <code>@bound</code> 类方法装饰器的例子，该装饰器自动为方法绑定 <code>this</code>：</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> bound <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> context<span class="token operator">:</span> ClassMemberDecoratorContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token keyword">private</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Not supported on private methods."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  context<span class="token punctuation">.</span><span class="token function">addInitializer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">[</span>context<span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>context<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n</li>\n<li>\n<p>metadata</p>\n<p>和装饰器类似，<a href="https://github.com/tc39/proposal-decorator-metadata">metadata</a> 也是处于 stage 3 阶段的一个提案。装饰器只能访问到类原型链、类实例的相关数据，而 metadata 给了开发者更大的自由，让程序于运行时访问到编译时决定的元数据。</p>\n<p>举个例子：</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">meta</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>_<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    context<span class="token punctuation">.</span>metadata<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n@<span class="token function">meta</span><span class="token punctuation">(</span><span class="token string">\'a\'</span><span class="token punctuation">,</span> <span class="token string">\'x\'</span><span class="token punctuation">)</span>\n<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>\n  @<span class="token function">meta</span><span class="token punctuation">(</span><span class="token string">\'b\'</span><span class="token punctuation">,</span> <span class="token string">\'y\'</span><span class="token punctuation">)</span>\n  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token constant">C</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>metadata<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// \'x\'</span>\n<span class="token constant">C</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>metadata<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span> <span class="token comment">// \'y\'</span>\n</code></pre>\n<p>在上述程序中，我们通过访问类的 <code>Symbol.metadata</code> ，读取到了 meta 装饰器所写入的元数据。对元数据的访问，有且仅有这一种形式。</p>\n<p>注意一点，metadata 是作用在类上的，即使它的位置在类方法上。想实现细粒度的元数据存储，可以考虑手动维护若干 <code>WeakMap</code>。</p>\n</li>\n</ul>\n<p>除了类装饰器以外，其他3种装饰器的 context 还拥有以下 3 个字段：</p>\n<ul>\n<li>\n<p>static</p>\n<p>布尔值，描述 value 是否为 static 所修饰。</p>\n</li>\n<li>\n<p>private</p>\n<p>布尔值，描述 value 是否为 private 所修饰。</p>\n</li>\n<li>\n<p>access</p>\n<p>一个对象，可在运行时访问 value 相关数据。</p>\n<p>以类方法装饰器为例，用 <code>access.get</code> 可在运行时读取方法值，<code>access.has</code> 可在运行时查询对象上是否有某方法，举个例子：</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> typeToYellingMap <span class="token operator">=</span> <span class="token punctuation">{</span>\n  cat<span class="token operator">:</span> <span class="token string">\'meow~ meow~\'</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> yellingMethodContext<span class="token operator">:</span> ClassMethodDecoratorContext\n\n<span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token keyword">type</span>\n  <span class="token punctuation">}</span>\n\n  @yelling\n  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, I\'m a(n) </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n\n  accessor y <span class="token operator">=</span> <span class="token number">1</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">yelling</span><span class="token punctuation">(</span>originalMethod<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> context<span class="token operator">:</span> ClassMethodDecoratorContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  yellingMethodContext <span class="token operator">=</span> context\n  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>typeToYellingMap<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token class-name"><span class="token keyword">as</span></span> <span class="token keyword">keyof</span> <span class="token keyword">typeof</span> typeToYellingMap<span class="token punctuation">]</span><span class="token punctuation">)</span>\n    <span class="token function">originalMethod</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> xcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">\'cat\'</span><span class="token punctuation">)</span>\nxcat<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// meow~ meow~</span>\n<span class="token comment">// Hello, I\'m a(n) cat!</span>\nyellingMethodContext<span class="token punctuation">.</span>access<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>xcat<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>xcat<span class="token punctuation">)</span> <span class="token comment">// meow~ meow~</span>\n<span class="token comment">// Hello, I\'m a(n) cat!</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>yellingMethodContext<span class="token punctuation">.</span>access<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>xcat<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n</code></pre>\n<p><code>getter</code> 类别的装饰器，其 <code>context.access</code> 同样拥有 <code>has</code>, <code>get</code> 两个方法。</p>\n<p>对于 <code>setter</code> 类别的装饰器，则是 <code>has</code> 与 <code>set</code> 方法。</p>\n<p><code>filed</code> 与 <code>accessor</code> 类别的装饰器，拥有 <code>has</code>, <code>get</code>, <code>set</code> 全部三个方法。</p>\n</li>\n</ul>'
        } }),
    'head': React.createElement(React.Fragment, null,
        React.createElement(Ga, { id: "UA-45256157-14" }),
        React.createElement("link", { href: "/favicon.png", rel: "icon", type: "image/png" })),
    'script': React.createElement(React.Fragment, null,
        React.createElement("script", { src: "https://cdn.pagic.org/react@18.2.0/umd/react.production.min.js" }),
        React.createElement("script", { src: "https://cdn.pagic.org/react-dom@18.2.0/umd/react-dom.production.min.js" }),
        React.createElement("script", { src: "/index.js", type: "module" })),
    'footer': React.createElement("footer", null,
        "Powered by\u00A0",
        React.createElement("a", { href: "https://github.com/xcatliu/pagic", target: "_blank" }, "Pagic")),
    'contentTitle': React.createElement("h1", { key: "0" }, "\u88C5\u9970\u5668"),
    'contentBody': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<p>写在前面：本章只介绍 TypeScript 5.0+ 的装饰器用法，对于 5.0 以下的版本，请参考 <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">TypeScript 官方文档</a></p>\n<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8">什么是装饰器<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8">§</a></h2>\n<p>首先，什么是装饰器呢？<a href="https://en.wikipedia.org/wiki/Decorator_pattern">维基百科</a>是这么说的：</p>\n<blockquote>\n<p>In <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented programming</a>, the <strong>decorator pattern</strong> is a <a href="https://en.wikipedia.org/wiki/Design_pattern_(computer_science)">design pattern</a> that allows behavior to be added to an individual <a href="https://en.wikipedia.org/wiki/Object_(computer_science)">object</a>, dynamically, without affecting the behavior of other instances of the same <a href="https://en.wikipedia.org/wiki/Class_(computer_science)">class</a>.</p>\n</blockquote>\n<p>本人的蹩足翻译：在 OOP (面向对象编程)中，装饰器模式是一种允许动态地往一个对象上添加自定义行为，而又不影响该对象所属的类的其他实例的一种设计模式。</p>\n<blockquote>\n<p>什么是 OOP 和类？<a href="https://ts.xcatliu.com/advanced/class.html">前面的章节</a>做过介绍。</p>\n</blockquote>\n<p>这句话未免过于拗口了，我们不妨换个角度去切入。</p>\n<h2 id="%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">装饰器的使用场景<a class="anchor" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">§</a></h2>\n<p>要知道，一切设计模式的诞生，都是为了解决某个问题。在 JavaScript 的世界中，装饰器通常出现于以下场景：</p>\n<ol>\n<li>\n<p>提供一种易读且容易实现的方式，修改类或者类的方法，避免出现大量重复的代码。</p>\n<p>下面以修改类的方法为例。</p>\n<p>首先，假设我们有一个 <code>Animal</code> 类：</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token keyword">type</span>\n  <span class="token punctuation">}</span>\n  \n  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, I\'m a(n) </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> xcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">\'cat\'</span><span class="token punctuation">)</span>\nxcat<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Hello, I\'m a(n) cat!</span>\n</code></pre>\n<p>该类有一个 greet 方法，和调用方打招呼。</p>\n<p>假如说，我还希望根据不同的 <code>type</code>，往 console 打印不同动物的叫声呢？</p>\n<p>聪明的你或许想到了，这不就是<strong>类的继承</strong>吗！在子类的 <code>greet()</code> 方法中，实现不同的逻辑，再调用 <code>super.greet()</code> 即可。</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Xcat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">\'cat\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  \n  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'meow~ meow~\'</span><span class="token punctuation">)</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> xcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Xcat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nxcat<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// meow~ meow~</span>\n             <span class="token comment">// Hello, I\'m a(n) cat!</span>\n</code></pre>\n<p>用装饰器实现，也不妨为一种思路，比如在 <code>Animal</code> 类中，为 <code>greet()</code> 方法添加「打印不同动物叫声的」行为:</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token keyword">type</span>\n  <span class="token punctuation">}</span>\n\n  @yelling\n  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, I\'m a(n) </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> typeToYellingMap <span class="token operator">=</span> <span class="token punctuation">{</span>\n  cat<span class="token operator">:</span> <span class="token string">\'meow~ meow~\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">yelling</span><span class="token punctuation">(</span>originalMethod<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> context<span class="token operator">:</span> ClassMethodDecoratorContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>typeToYellingMap<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n    <span class="token function">originalMethod</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> xcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">\'cat\'</span><span class="token punctuation">)</span>\nxcat<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// meow~ meow~</span>\n             <span class="token comment">// Hello, I\'m a(n) cat!</span>\n</code></pre>\n<p>在 <code>Animal.greet()</code> 方法上出现的 <code>@yelling</code> ，就是 TypeScript 中装饰器的写法，即 @ + 函数名的组合。</p>\n<p>上述示例对装饰器的应用属于<strong>方法装饰器</strong>，此类装饰器本身接收两个参数，一是被装饰的方法，二是方法装饰器的上下文。方法装饰器应返回一个函数，此函数在运行时真正被执行。在上述例子中，我们在装饰器返回的函数中做了两件事情：</p>\n<ol>\n<li>打印相应类别的动物的叫声。</li>\n<li>调用 <code>originalMethod.call(this, …args)</code> ，确保原方法（即装饰器所装饰的方法）能够正确地被执行。</li>\n</ol>\n</li>\n<li>\n<p>结合「<strong>依赖注入</strong>」这一设计模式，优化模块与 class 的依赖关系。</p>\n<p>什么是依赖注入呢？引用同事 <a href="https://github.com/ziofat">zio</a> 的原话：</p>\n<blockquote>\n<p><strong>依赖注入其实是将一个模块所依赖的部分作为参数传入，而不是由模块自己去构造。</strong></p>\n</blockquote>\n<p>可见，依赖注入解决了实际工程项目中，类、模块间依赖关系层级复杂的问题，将构造单例的行为交由实现依赖注入的框架去处理。</p>\n<p>举个例子：</p>\n<pre class="language-ts"><code class="language-ts">@injectable\n<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">implements</span> <span class="token class-name">IAnimal</span> <span class="token punctuation">{</span>\n  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'woof woof woof\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n@injectable\n<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">IAnimal</span> <span class="token punctuation">{</span>\n  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'meow meow meow\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">AnimalService</span> <span class="token punctuation">{</span>\n  <span class="token keyword">constructor</span><span class="token punctuation">(</span>\n    @inject dog<span class="token operator">:</span> Dog\n    @inject cat<span class="token operator">:</span> Cat\n  <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>_dog <span class="token operator">=</span> dog\n    <span class="token keyword">this</span><span class="token punctuation">.</span>_cat <span class="token operator">=</span> cat\n  <span class="token punctuation">}</span>\n  \n  <span class="token function">sayHiByDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>_dog<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  \n  <span class="token function">sayHiByCat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>_cat<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>在上述代码中，<code>@injectable</code> 将一个类标记为「可被注入的」，在面向业务的类（即 <code>AnimalService</code>）中，使用 <code>@inject</code> 注入此类的单例，实现了「依赖倒置」。注意到这里的 <code>implements IAnimal</code> 用法，也是实战中依赖注入运用的精妙之处 —— 关心接口，而非具体实现。</p>\n</li>\n<li>\n<p>实现「AOP」，即 Aspect-oriented programming，面向切面编程。</p>\n<p>所谓的「切面」，可以理解成，在复杂的各个业务维度中，只关注一个维度的事务。</p>\n<p>例如，使用装饰器，实现对类的某个方法的执行时间记录：</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>\n  @recordExecution\n  <span class="token function">myFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// do something...</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">recordExecution</span><span class="token punctuation">(</span>originalMethod<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> context<span class="token operator">:</span> ClassMethodDecoratorContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">\'mark execution\'</span><span class="token punctuation">)</span>\n    <span class="token function">originalMethod</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">\'mark execution\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n</li>\n</ol>\n<h2 id="%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%B1%BB%E5%88%AB">装饰器的类别<a class="anchor" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%B1%BB%E5%88%AB">§</a></h2>\n<p>通过以上例子，相信读者已经对装饰器有一定了解，且认识到了装饰器在一些场景的强大之处。在此引用<a href="https://es6.ruanyifeng.com/#docs/decorator#%E7%AE%80%E4%BB%8B%EF%BC%88%E6%96%B0%E8%AF%AD%E6%B3%95%EF%BC%89">阮一峰 es6 教程</a>稍做总结：</p>\n<blockquote>\n<p>装饰器是一种函数，写成<code>@ + 函数名</code>，可以用来装饰四种类型的值。</p>\n<ul>\n<li>类</li>\n<li>类的属性</li>\n<li>类的方法</li>\n<li>属性存取器（accessor, getter, setter）</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>装饰器的执行步骤如下。</p>\n<ol>\n<li>计算各个装饰器的值，按照从左到右，从上到下的顺序。</li>\n<li>调用方法装饰器。</li>\n<li>调用类装饰器。</li>\n</ol>\n</blockquote>\n<p>不管是哪种类型的装饰器，它们的函数签名都可以认为是一致的，即均接收 <code>value</code>, <code>context</code> 两个参数，前者指被装饰的对象，后者指一个存储了上下文信息的对象。</p>\n<h2 id="context-%E4%B8%8E-metadata-%E4%BA%8C%E4%B8%89%E8%AE%B2">context 与 metadata 二三讲<a class="anchor" href="#context-%E4%B8%8E-metadata-%E4%BA%8C%E4%B8%89%E8%AE%B2">§</a></h2>\n<p>四种装饰器的 context，均包含以下信息：</p>\n<ul>\n<li>\n<p>kind</p>\n<p>描述被装饰的 value 的类型，可取 <code>class</code>, <code>method</code>, <code>field</code>, <code>getter</code>, <code>setter</code>, <code>accessor</code> 这些值。</p>\n</li>\n<li>\n<p>name</p>\n<p>描述被装饰的 value 的名字。</p>\n</li>\n<li>\n<p>addInitializer</p>\n<p>一个方法，接收一个回调函数，使得开发者可以侵入 value 的初始化过程作修改。</p>\n<p>对 <code>class</code> 来说，这个回调函数会在类定义最终确认后调用，即相当于在初始化过程的最后一步。</p>\n<p>对其他的 value 来说，如果是被 <code>static</code> 所修饰的，则会在类定义期间被调用，且早于其他静态属性的赋值过程；否则，会在类初始化期间被调用，且早于 value 自身的初始化。</p>\n<p>以下是 <code>@bound</code> 类方法装饰器的例子，该装饰器自动为方法绑定 <code>this</code>：</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> bound <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> context<span class="token operator">:</span> ClassMemberDecoratorContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token keyword">private</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Not supported on private methods."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  context<span class="token punctuation">.</span><span class="token function">addInitializer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">[</span>context<span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>context<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n</li>\n<li>\n<p>metadata</p>\n<p>和装饰器类似，<a href="https://github.com/tc39/proposal-decorator-metadata">metadata</a> 也是处于 stage 3 阶段的一个提案。装饰器只能访问到类原型链、类实例的相关数据，而 metadata 给了开发者更大的自由，让程序于运行时访问到编译时决定的元数据。</p>\n<p>举个例子：</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">meta</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>_<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    context<span class="token punctuation">.</span>metadata<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n@<span class="token function">meta</span><span class="token punctuation">(</span><span class="token string">\'a\'</span><span class="token punctuation">,</span> <span class="token string">\'x\'</span><span class="token punctuation">)</span>\n<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>\n  @<span class="token function">meta</span><span class="token punctuation">(</span><span class="token string">\'b\'</span><span class="token punctuation">,</span> <span class="token string">\'y\'</span><span class="token punctuation">)</span>\n  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token constant">C</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>metadata<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// \'x\'</span>\n<span class="token constant">C</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>metadata<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span> <span class="token comment">// \'y\'</span>\n</code></pre>\n<p>在上述程序中，我们通过访问类的 <code>Symbol.metadata</code> ，读取到了 meta 装饰器所写入的元数据。对元数据的访问，有且仅有这一种形式。</p>\n<p>注意一点，metadata 是作用在类上的，即使它的位置在类方法上。想实现细粒度的元数据存储，可以考虑手动维护若干 <code>WeakMap</code>。</p>\n</li>\n</ul>\n<p>除了类装饰器以外，其他3种装饰器的 context 还拥有以下 3 个字段：</p>\n<ul>\n<li>\n<p>static</p>\n<p>布尔值，描述 value 是否为 static 所修饰。</p>\n</li>\n<li>\n<p>private</p>\n<p>布尔值，描述 value 是否为 private 所修饰。</p>\n</li>\n<li>\n<p>access</p>\n<p>一个对象，可在运行时访问 value 相关数据。</p>\n<p>以类方法装饰器为例，用 <code>access.get</code> 可在运行时读取方法值，<code>access.has</code> 可在运行时查询对象上是否有某方法，举个例子：</p>\n<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> typeToYellingMap <span class="token operator">=</span> <span class="token punctuation">{</span>\n  cat<span class="token operator">:</span> <span class="token string">\'meow~ meow~\'</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> yellingMethodContext<span class="token operator">:</span> ClassMethodDecoratorContext\n\n<span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token keyword">type</span>\n  <span class="token punctuation">}</span>\n\n  @yelling\n  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, I\'m a(n) </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n\n  accessor y <span class="token operator">=</span> <span class="token number">1</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">yelling</span><span class="token punctuation">(</span>originalMethod<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> context<span class="token operator">:</span> ClassMethodDecoratorContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  yellingMethodContext <span class="token operator">=</span> context\n  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>typeToYellingMap<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token class-name"><span class="token keyword">as</span></span> <span class="token keyword">keyof</span> <span class="token keyword">typeof</span> typeToYellingMap<span class="token punctuation">]</span><span class="token punctuation">)</span>\n    <span class="token function">originalMethod</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> xcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">\'cat\'</span><span class="token punctuation">)</span>\nxcat<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// meow~ meow~</span>\n<span class="token comment">// Hello, I\'m a(n) cat!</span>\nyellingMethodContext<span class="token punctuation">.</span>access<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>xcat<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>xcat<span class="token punctuation">)</span> <span class="token comment">// meow~ meow~</span>\n<span class="token comment">// Hello, I\'m a(n) cat!</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>yellingMethodContext<span class="token punctuation">.</span>access<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>xcat<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n</code></pre>\n<p><code>getter</code> 类别的装饰器，其 <code>context.access</code> 同样拥有 <code>has</code>, <code>get</code> 两个方法。</p>\n<p>对于 <code>setter</code> 类别的装饰器，则是 <code>has</code> 与 <code>set</code> 方法。</p>\n<p><code>filed</code> 与 <code>accessor</code> 类别的装饰器，拥有 <code>has</code>, <code>get</code>, <code>set</code> 全部三个方法。</p>\n</li>\n</ul>'
        } }),
    'toc': React.createElement("nav", { key: "0", className: "toc" },
        React.createElement("ol", null,
            React.createElement("li", null,
                React.createElement("a", { href: "#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8" }, "\u4EC0\u4E48\u662F\u88C5\u9970\u5668")),
            React.createElement("li", null,
                React.createElement("a", { href: "#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" }, "\u88C5\u9970\u5668\u7684\u4F7F\u7528\u573A\u666F")),
            React.createElement("li", null,
                React.createElement("a", { href: "#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%B1%BB%E5%88%AB" }, "\u88C5\u9970\u5668\u7684\u7C7B\u522B")),
            React.createElement("li", null,
                React.createElement("a", { href: "#context-%E4%B8%8E-metadata-%E4%BA%8C%E4%B8%89%E8%AE%B2" }, "context \u4E0E metadata \u4E8C\u4E09\u8BB2")))),
    'author': "younggglcy",
    'contributors': [
        "younggglcy"
    ],
    'date': "2024-08-04T14:31:37.000Z",
    'updated': "2024-08-14T16:40:55.000Z",
    'excerpt': "写在前面：本章只介绍 TypeScript 5.0+ 的装饰器用法，对于 5.0 以下的版本，请参考 TypeScript 官方文档 什么是装饰器 首先，什么是装饰器呢？维基百科是这么说的： 本人的蹩足翻译：在 OOP (面向对象编程)中，装饰器模式是一...",
    'cover': undefined,
    'sidebar': [
        {
            "link": "introduction/index.html",
            "children": [
                {
                    "text": "什么是 TypeScript",
                    "link": "introduction/what-is-typescript.html",
                    "pagePath": "introduction/what-is-typescript.md"
                },
                {
                    "text": "安装 TypeScript",
                    "link": "introduction/get-typescript.html",
                    "pagePath": "introduction/get-typescript.md"
                },
                {
                    "text": "Hello TypeScript",
                    "link": "introduction/hello-typescript.html",
                    "pagePath": "introduction/hello-typescript.md"
                }
            ],
            "pagePath": "introduction/README.md",
            "text": "简介"
        },
        {
            "link": "basics/index.html",
            "children": [
                {
                    "text": "原始数据类型",
                    "link": "basics/primitive-data-types.html",
                    "pagePath": "basics/primitive-data-types.md"
                },
                {
                    "text": "任意值",
                    "link": "basics/any.html",
                    "pagePath": "basics/any.md"
                },
                {
                    "text": "类型推论",
                    "link": "basics/type-inference.html",
                    "pagePath": "basics/type-inference.md"
                },
                {
                    "text": "联合类型",
                    "link": "basics/union-types.html",
                    "pagePath": "basics/union-types.md"
                },
                {
                    "text": "对象的类型——接口",
                    "link": "basics/type-of-object-interfaces.html",
                    "pagePath": "basics/type-of-object-interfaces.md"
                },
                {
                    "text": "数组的类型",
                    "link": "basics/type-of-array.html",
                    "pagePath": "basics/type-of-array.md"
                },
                {
                    "text": "函数的类型",
                    "link": "basics/type-of-function.html",
                    "pagePath": "basics/type-of-function.md"
                },
                {
                    "text": "类型断言",
                    "link": "basics/type-assertion.html",
                    "pagePath": "basics/type-assertion.md"
                },
                {
                    "text": "声明文件",
                    "link": "basics/declaration-files.html",
                    "pagePath": "basics/declaration-files.md"
                },
                {
                    "text": "内置对象",
                    "link": "basics/built-in-objects.html",
                    "pagePath": "basics/built-in-objects.md"
                }
            ],
            "pagePath": "basics/README.md",
            "text": "基础"
        },
        {
            "link": "advanced/index.html",
            "children": [
                {
                    "text": "类型别名",
                    "link": "advanced/type-aliases.html",
                    "pagePath": "advanced/type-aliases.md"
                },
                {
                    "text": "字符串字面量类型",
                    "link": "advanced/string-literal-types.html",
                    "pagePath": "advanced/string-literal-types.md"
                },
                {
                    "text": "元组",
                    "link": "advanced/tuple.html",
                    "pagePath": "advanced/tuple.md"
                },
                {
                    "text": "枚举",
                    "link": "advanced/enum.html",
                    "pagePath": "advanced/enum.md"
                },
                {
                    "text": "类",
                    "link": "advanced/class.html",
                    "pagePath": "advanced/class.md"
                },
                {
                    "text": "类与接口",
                    "link": "advanced/class-and-interfaces.html",
                    "pagePath": "advanced/class-and-interfaces.md"
                },
                {
                    "text": "泛型",
                    "link": "advanced/generics.html",
                    "pagePath": "advanced/generics.md"
                },
                {
                    "text": "声明合并",
                    "link": "advanced/declaration-merging.html",
                    "pagePath": "advanced/declaration-merging.md"
                },
                {
                    "text": "装饰器",
                    "link": "advanced/decorator.html",
                    "pagePath": "advanced/decorator.md"
                },
                {
                    "text": "扩展阅读",
                    "link": "advanced/further-reading.html",
                    "pagePath": "advanced/further-reading.md"
                }
            ],
            "pagePath": "advanced/README.md",
            "text": "进阶"
        },
        {
            "link": "engineering/index.html",
            "children": [
                {
                    "text": "代码检查",
                    "link": "engineering/lint.html",
                    "pagePath": "engineering/lint.md"
                },
                {
                    "text": "编译选项",
                    "link": "engineering/compiler-options.html",
                    "pagePath": "engineering/compiler-options.md"
                }
            ],
            "pagePath": "engineering/README.md",
            "text": "工程"
        },
        {
            "text": "感谢",
            "link": "thanks/index.html",
            "pagePath": "thanks/README.md"
        }
    ],
    'gitalk': React.createElement(Gitalk, { admin: [
            'xcatliu'
        ], clientID: "29aa4941759fc887ed4f", clientSecret: "33e355efdf3a1959624506a5d88311145208471b", id: "advanced/decorator.html", owner: "xcatliu", pagerDirection: "first", repo: "typescript-tutorial", title: "\u88C5\u9970\u5668" })
};
