<!doctype html><html class=""><head><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
            window.GoogleAnalyticsObject="ga";(window.ga=window.ga||function(){(window.ga.q=window.ga.q||[]).push(arguments);}),(window.ga.l=1*new Date());

            ga('create', 'UA-45256157-14', 'auto');
            ga('send', 'pageview');</script><link rel="icon" type="image/png" href="/favicon.png"/>
<meta data-react-helmet="true" charset="utf-8"/><meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"/><meta data-react-helmet="true" name="description" content="从 JavaScript 程序员的角度总结思考，循序渐进的理解 TypeScript"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/><meta data-react-helmet="true" property="og:title" content="装饰器 · TypeScript 入门教程"/><meta data-react-helmet="true" property="og:description" content="从 JavaScript 程序员的角度总结思考，循序渐进的理解 TypeScript"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" name="twitter:card" content="summary"/>
<title data-react-helmet="true">装饰器 · TypeScript 入门教程</title>
<link data-react-helmet="true" rel="stylesheet" href="/assets/index.css"/><link data-react-helmet="true" id="prismTheme" rel="stylesheet" href="/assets/prism.css"/>
<script data-react-helmet="true" >
    const shouldSetIsDark = document.cookie.includes('is_dark=1') ? true : document.cookie.includes('is_dark=0') ? false : window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (shouldSetIsDark) {
      document.documentElement.classList.add('is_dark');
      document.getElementById('prismTheme').href = "/assets/prism_tomorrow.css";
    }
  </script>
</head><body><header><h1 class="hide_on_mobile"><a href="/">TypeScript 入门教程</a></h1><nav><ul><li class="show_on_mobile flex_center"><a class="czs-menu-l" href="#" style="background-image:url(&quot;/assets/czs-menu-l.svg&quot;)"></a></li><li class="show_on_mobile"><h1 class="mobile_title"><a href="/">TypeScript 入门教程</a></h1></li><li class="hide_on_mobile"><a href="https://github.com/xcatliu/buy-me-a-coffee" target="_blank">赞助作者</a></li><li class="hide_on_mobile"><a>加入微信群</a></li><li class="hide_on_mobile"><a href="https://jq.qq.com/?_wv=1027&amp;k=5nkkFCl" target="_blank">加入 QQ 群</a></li><li class="hide_on_mobile"><a href="https://github.com/xcatliu/pagic" target="_blank">本网站使用 Pagic 构建</a></li><li style="flex-grow:1"></li><li class="flex_center"><a class="czs-github-logo" href="https://github.com/xcatliu/typescript-tutorial" target="_blank" style="background-image:url(&quot;/assets/czs-github-logo.svg&quot;)"></a></li><li class="toggle_dark flex_center"><span class="czs-sun" style="background-image:url(&quot;/assets/czs-sun.svg&quot;)"></span><span class="czs-sun-l" style="background-image:url(&quot;/assets/czs-sun-l.svg&quot;)"></span><span class="czs-moon" style="background-image:url(&quot;/assets/czs-moon.svg&quot;)"></span><span class="czs-moon-l" style="background-image:url(&quot;/assets/czs-moon-l.svg&quot;)"></span></li></ul></nav></header><aside class="sidebar"><ol class="list_style_none"><li class="unfold"><a href="/introduction/index.html" class="nav_link">简介<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol class="list_style_none" style="height:auto"><li class=""><a href="/introduction/what-is-typescript.html" class="nav_link">什么是 TypeScript</a></li><li class=""><a href="/introduction/get-typescript.html" class="nav_link">安装 TypeScript</a></li><li class=""><a href="/introduction/hello-typescript.html" class="nav_link">Hello TypeScript</a></li></ol></li><li class="unfold"><a href="/basics/index.html" class="nav_link">基础<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol class="list_style_none" style="height:auto"><li class=""><a href="/basics/primitive-data-types.html" class="nav_link">原始数据类型</a></li><li class=""><a href="/basics/any.html" class="nav_link">任意值</a></li><li class=""><a href="/basics/type-inference.html" class="nav_link">类型推论</a></li><li class=""><a href="/basics/union-types.html" class="nav_link">联合类型</a></li><li class=""><a href="/basics/type-of-object-interfaces.html" class="nav_link">对象的类型——接口</a></li><li class=""><a href="/basics/type-of-array.html" class="nav_link">数组的类型</a></li><li class=""><a href="/basics/type-of-function.html" class="nav_link">函数的类型</a></li><li class=""><a href="/basics/type-assertion.html" class="nav_link">类型断言</a></li><li class=""><a href="/basics/declaration-files.html" class="nav_link">声明文件</a></li><li class=""><a href="/basics/built-in-objects.html" class="nav_link">内置对象</a></li></ol></li><li class="unfold"><a href="/advanced/index.html" class="nav_link">进阶<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol class="list_style_none" style="height:auto"><li class=""><a href="/advanced/type-aliases.html" class="nav_link">类型别名</a></li><li class=""><a href="/advanced/string-literal-types.html" class="nav_link">字符串字面量类型</a></li><li class=""><a href="/advanced/tuple.html" class="nav_link">元组</a></li><li class=""><a href="/advanced/enum.html" class="nav_link">枚举</a></li><li class=""><a href="/advanced/class.html" class="nav_link">类</a></li><li class=""><a href="/advanced/class-and-interfaces.html" class="nav_link">类与接口</a></li><li class=""><a href="/advanced/generics.html" class="nav_link">泛型</a></li><li class=""><a href="/advanced/declaration-merging.html" class="nav_link">声明合并</a></li><li class=""><a href="/advanced/decorator.html" class="nav_link active">装饰器</a></li><li class=""><a href="/advanced/further-reading.html" class="nav_link">扩展阅读</a></li></ol></li><li class="unfold"><a href="/engineering/index.html" class="nav_link">工程<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol class="list_style_none" style="height:auto"><li class=""><a href="/engineering/lint.html" class="nav_link">代码检查</a></li><li class=""><a href="/engineering/compiler-options.html" class="nav_link">编译选项</a></li></ol></li><li class=""><a href="/thanks/index.html" class="nav_link">感谢</a></li></ol></aside><section class="main"><div class="main_article"><article><h1>装饰器</h1>
<p>写在前面：本章只介绍 TypeScript 5.0+ 的装饰器用法，对于 5.0 以下的版本，请参考 <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">TypeScript 官方文档</a></p>
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8">什么是装饰器<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8">§</a></h2>
<p>首先，什么是装饰器呢？<a href="https://en.wikipedia.org/wiki/Decorator_pattern">维基百科</a>是这么说的：</p>
<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented programming</a>, the <strong>decorator pattern</strong> is a <a href="https://en.wikipedia.org/wiki/Design_pattern_(computer_science)">design pattern</a> that allows behavior to be added to an individual <a href="https://en.wikipedia.org/wiki/Object_(computer_science)">object</a>, dynamically, without affecting the behavior of other instances of the same <a href="https://en.wikipedia.org/wiki/Class_(computer_science)">class</a>.</p>
</blockquote>
<p>本人的蹩足翻译：在 OOP (面向对象编程)中，装饰器模式是一种允许动态地往一个对象上添加自定义行为，而又不影响该对象所属的类的其他实例的一种设计模式。</p>
<blockquote>
<p>什么是 OOP 和类？<a href="https://ts.xcatliu.com/advanced/class.html">前面的章节</a>做过介绍。</p>
</blockquote>
<p>这句话未免过于拗口了，我们不妨换个角度去切入。</p>
<h2 id="%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">装饰器的使用场景<a class="anchor" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">§</a></h2>
<p>要知道，一切设计模式的诞生，都是为了解决某个问题。在 JavaScript 的世界中，装饰器通常出现于以下场景：</p>
<ol>
<li>
<p>提供一种易读且容易实现的方式，修改类或者类的方法，避免出现大量重复的代码。</p>
<p>下面以修改类的方法为例。</p>
<p>首先，假设我们有一个 <code>Animal</code> 类：</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token keyword">type</span>
  <span class="token punctuation">}</span>
  
  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, I'm a(n) </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> xcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">)</span>
xcat<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Hello, I'm a(n) cat!</span>
</code></pre>
<p>该类有一个 greet 方法，和调用方打招呼。</p>
<p>假如说，我还希望根据不同的 <code>type</code>，往 console 打印不同动物的叫声呢？</p>
<p>聪明的你或许想到了，这不就是<strong>类的继承</strong>吗！在子类的 <code>greet()</code> 方法中，实现不同的逻辑，再调用 <code>super.greet()</code> 即可。</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Xcat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'meow~ meow~'</span><span class="token punctuation">)</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> xcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Xcat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
xcat<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// meow~ meow~</span>
             <span class="token comment">// Hello, I'm a(n) cat!</span>
</code></pre>
<p>用装饰器实现，也不妨为一种思路，比如在 <code>Animal</code> 类中，为 <code>greet()</code> 方法添加「打印不同动物叫声的」行为:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token keyword">type</span>
  <span class="token punctuation">}</span>

  @yelling
  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, I'm a(n) </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> typeToYellingMap <span class="token operator">=</span> <span class="token punctuation">{</span>
  cat<span class="token operator">:</span> <span class="token string">'meow~ meow~'</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">yelling</span><span class="token punctuation">(</span>originalMethod<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> context<span class="token operator">:</span> ClassMethodDecoratorContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>typeToYellingMap<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token function">originalMethod</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> xcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">)</span>
xcat<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// meow~ meow~</span>
             <span class="token comment">// Hello, I'm a(n) cat!</span>
</code></pre>
<p>在 <code>Animal.greet()</code> 方法上出现的 <code>@yelling</code> ，就是 TypeScript 中装饰器的写法，即 @ + 函数名的组合。</p>
<p>上述示例对装饰器的应用属于<strong>方法装饰器</strong>，此类装饰器本身接收两个参数，一是被装饰的方法，二是方法装饰器的上下文。方法装饰器应返回一个函数，此函数在运行时真正被执行。在上述例子中，我们在装饰器返回的函数中做了两件事情：</p>
<ol>
<li>打印相应类别的动物的叫声。</li>
<li>调用 <code>originalMethod.call(this, …args)</code> ，确保原方法（即装饰器所装饰的方法）能够正确地被执行。</li>
</ol>
</li>
<li>
<p>结合「<strong>依赖注入</strong>」这一设计模式，优化模块与 class 的依赖关系。</p>
<p>什么是依赖注入呢？引用同事 <a href="https://github.com/ziofat">zio</a> 的原话：</p>
<blockquote>
<p><strong>依赖注入其实是将一个模块所依赖的部分作为参数传入，而不是由模块自己去构造。</strong></p>
</blockquote>
<p>可见，依赖注入解决了实际工程项目中，类、模块间依赖关系层级复杂的问题，将构造单例的行为交由实现依赖注入的框架去处理。</p>
<p>举个例子：</p>
<pre class="language-ts"><code class="language-ts">@injectable
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">implements</span> <span class="token class-name">IAnimal</span> <span class="token punctuation">{</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'woof woof woof'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

@injectable
<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">IAnimal</span> <span class="token punctuation">{</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'meow meow meow'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">AnimalService</span> <span class="token punctuation">{</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span>
    @inject dog<span class="token operator">:</span> Dog
    @inject cat<span class="token operator">:</span> Cat
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_dog <span class="token operator">=</span> dog
    <span class="token keyword">this</span><span class="token punctuation">.</span>_cat <span class="token operator">=</span> cat
  <span class="token punctuation">}</span>
  
  <span class="token function">sayHiByDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_dog<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  <span class="token function">sayHiByCat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_cat<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在上述代码中，<code>@injectable</code> 将一个类标记为「可被注入的」，在面向业务的类（即 <code>AnimalService</code>）中，使用 <code>@inject</code> 注入此类的单例，实现了「依赖倒置」。注意到这里的 <code>implements IAnimal</code> 用法，也是实战中依赖注入运用的精妙之处 —— 关心接口，而非具体实现。</p>
</li>
<li>
<p>实现「AOP」，即 Aspect-oriented programming，面向切面编程。</p>
<p>所谓的「切面」，可以理解成，在复杂的各个业务维度中，只关注一个维度的事务。</p>
<p>例如，使用装饰器，实现对类的某个方法的执行时间记录：</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>
  @recordExecution
  <span class="token function">myFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do something...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">recordExecution</span><span class="token punctuation">(</span>originalMethod<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> context<span class="token operator">:</span> ClassMethodDecoratorContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'mark execution'</span><span class="token punctuation">)</span>
    <span class="token function">originalMethod</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'mark execution'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
</ol>
<h2 id="%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%B1%BB%E5%88%AB">装饰器的类别<a class="anchor" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%B1%BB%E5%88%AB">§</a></h2>
<p>通过以上例子，相信读者已经对装饰器有一定了解，且认识到了装饰器在一些场景的强大之处。在此引用<a href="https://es6.ruanyifeng.com/#docs/decorator#%E7%AE%80%E4%BB%8B%EF%BC%88%E6%96%B0%E8%AF%AD%E6%B3%95%EF%BC%89">阮一峰 es6 教程</a>稍做总结：</p>
<blockquote>
<p>装饰器是一种函数，写成<code>@ + 函数名</code>，可以用来装饰四种类型的值。</p>
<ul>
<li>类</li>
<li>类的属性</li>
<li>类的方法</li>
<li>属性存取器（accessor, getter, setter）</li>
</ul>
</blockquote>
<blockquote>
<p>装饰器的执行步骤如下。</p>
<ol>
<li>计算各个装饰器的值，按照从左到右，从上到下的顺序。</li>
<li>调用方法装饰器。</li>
<li>调用类装饰器。</li>
</ol>
</blockquote>
<p>不管是哪种类型的装饰器，它们的函数签名都可以认为是一致的，即均接收 <code>value</code>, <code>context</code> 两个参数，前者指被装饰的对象，后者指一个存储了上下文信息的对象。</p>
<h2 id="context-%E4%B8%8E-metadata-%E4%BA%8C%E4%B8%89%E8%AE%B2">context 与 metadata 二三讲<a class="anchor" href="#context-%E4%B8%8E-metadata-%E4%BA%8C%E4%B8%89%E8%AE%B2">§</a></h2>
<p>四种装饰器的 context，均包含以下信息：</p>
<ul>
<li>
<p>kind</p>
<p>描述被装饰的 value 的类型，可取 <code>class</code>, <code>method</code>, <code>field</code>, <code>getter</code>, <code>setter</code>, <code>accessor</code> 这些值。</p>
</li>
<li>
<p>name</p>
<p>描述被装饰的 value 的名字。</p>
</li>
<li>
<p>addInitializer</p>
<p>一个方法，接收一个回调函数，使得开发者可以侵入 value 的初始化过程作修改。</p>
<p>对 <code>class</code> 来说，这个回调函数会在类定义最终确认后调用，即相当于在初始化过程的最后一步。</p>
<p>对其他的 value 来说，如果是被 <code>static</code> 所修饰的，则会在类定义期间被调用，且早于其他静态属性的赋值过程；否则，会在类初始化期间被调用，且早于 value 自身的初始化。</p>
<p>以下是 <code>@bound</code> 类方法装饰器的例子，该装饰器自动为方法绑定 <code>this</code>：</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> bound <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> context<span class="token operator">:</span> ClassMemberDecoratorContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token keyword">private</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Not supported on private methods."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  context<span class="token punctuation">.</span><span class="token function">addInitializer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">[</span>context<span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>context<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li>
<p>metadata</p>
<p>和装饰器类似，<a href="https://github.com/tc39/proposal-decorator-metadata">metadata</a> 也是处于 stage 3 阶段的一个提案。装饰器只能访问到类原型链、类实例的相关数据，而 metadata 给了开发者更大的自由，让程序于运行时访问到编译时决定的元数据。</p>
<p>举个例子：</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">meta</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>_<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    context<span class="token punctuation">.</span>metadata<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

@<span class="token function">meta</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  @<span class="token function">meta</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">)</span>
  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token constant">C</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>metadata<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 'x'</span>
<span class="token constant">C</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>metadata<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span> <span class="token comment">// 'y'</span>
</code></pre>
<p>在上述程序中，我们通过访问类的 <code>Symbol.metadata</code> ，读取到了 meta 装饰器所写入的元数据。对元数据的访问，有且仅有这一种形式。</p>
<p>注意一点，metadata 是作用在类上的，即使它的位置在类方法上。想实现细粒度的元数据存储，可以考虑手动维护若干 <code>WeakMap</code>。</p>
</li>
</ul>
<p>除了类装饰器以外，其他3种装饰器的 context 还拥有以下 3 个字段：</p>
<ul>
<li>
<p>static</p>
<p>布尔值，描述 value 是否为 static 所修饰。</p>
</li>
<li>
<p>private</p>
<p>布尔值，描述 value 是否为 private 所修饰。</p>
</li>
<li>
<p>access</p>
<p>一个对象，可在运行时访问 value 相关数据。</p>
<p>以类方法装饰器为例，用 <code>access.get</code> 可在运行时读取方法值，<code>access.has</code> 可在运行时查询对象上是否有某方法，举个例子：</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> typeToYellingMap <span class="token operator">=</span> <span class="token punctuation">{</span>
  cat<span class="token operator">:</span> <span class="token string">'meow~ meow~'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> yellingMethodContext<span class="token operator">:</span> ClassMethodDecoratorContext

<span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token keyword">type</span>
  <span class="token punctuation">}</span>

  @yelling
  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, I'm a(n) </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  accessor y <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">yelling</span><span class="token punctuation">(</span>originalMethod<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> context<span class="token operator">:</span> ClassMethodDecoratorContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  yellingMethodContext <span class="token operator">=</span> context
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>typeToYellingMap<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token class-name"><span class="token keyword">as</span></span> <span class="token keyword">keyof</span> <span class="token keyword">typeof</span> typeToYellingMap<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token function">originalMethod</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> xcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">)</span>
xcat<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// meow~ meow~</span>
<span class="token comment">// Hello, I'm a(n) cat!</span>
yellingMethodContext<span class="token punctuation">.</span>access<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>xcat<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>xcat<span class="token punctuation">)</span> <span class="token comment">// meow~ meow~</span>
<span class="token comment">// Hello, I'm a(n) cat!</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>yellingMethodContext<span class="token punctuation">.</span>access<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>xcat<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre>
<p><code>getter</code> 类别的装饰器，其 <code>context.access</code> 同样拥有 <code>has</code>, <code>get</code> 两个方法。</p>
<p>对于 <code>setter</code> 类别的装饰器，则是 <code>has</code> 与 <code>set</code> 方法。</p>
<p><code>filed</code> 与 <code>accessor</code> 类别的装饰器，拥有 <code>has</code>, <code>get</code>, <code>set</code> 全部三个方法。</p>
</li>
</ul></article><div class="prev_next"><a class="prev button" href="/advanced/declaration-merging.html">«  声明合并</a><a class="next button" href="/advanced/further-reading.html">扩展阅读  »</a></div><div id="gitalk-container"></div><link id="gitalk-css" rel="preload" href="https://cdn.pagic.org/gitalk@1.6.2/dist/gitalk.css" as="style"/><script defer="" src="https://cdn.pagic.org/gitalk@1.6.2/dist/gitalk.min.js"></script></div><aside class="main_toc_container nav_link_container"><div class="main_toc"><nav class="toc"><ol><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8">什么是装饰器</a></li><li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">装饰器的使用场景</a></li><li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%B1%BB%E5%88%AB">装饰器的类别</a></li><li><a href="#context-%E4%B8%8E-metadata-%E4%BA%8C%E4%B8%89%E8%AE%B2">context 与 metadata 二三讲</a></li></ol></nav></div></aside></section><footer>Powered by&amp;nbsp;<a href="https://github.com/xcatliu/pagic" target="_blank">Pagic</a></footer><div class="tools flex_center hide_on_mobile"><a class="czs-pen button" href="https://github.com/xcatliu/typescript-tutorial/edit/master/./advanced/decorator.md" target="_blank" style="background-image:url(&quot;/assets/czs-pen.svg&quot;)"></a><a class="czs-angle-up-l button" href="#" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></a></div><script src="https://cdn.pagic.org/react@18.2.0/umd/react.production.min.js"></script><script src="https://cdn.pagic.org/react-dom@18.2.0/umd/react-dom.production.min.js"></script><script type="module" src="/index.js"></script></body></html>